项目的目录结构是:
src/main
├── java
│   └── com
│       └── example
│           └── diettracker
│               ├── DietTrackerApplication.java
│               ├── OrToolsInitializer.java
│               ├── controller
│               │   ├── AuthController.java
│               │   ├── FoodController.java
│               │   └── MealPlanController.java
│               ├── filter
│               │   └── TokenFilter.java
│               ├── model
│               │   ├── DietDailyInput.java
│               │   ├── Food.java
│               │   ├── Recommendation.java
│               │   ├── SetGoal.java
│               │   ├── User.java
│               │   ├── User_old.java
│               │   └── WeightInput.java
│               ├── repository
│               │   ├── FoodRepository.java
│               │   └── UserRepository.java
│               ├── security
│               │   ├── JwtAuthenticationFilter.java
│               │   └── SecurityConfig.java
│               ├── service
│               │   ├── AuthService.java
│               │   ├── FoodService.java
│               │   ├── MealPlanService.java
│               │   └── impl
│               │       └── AuthServiceImpl.java
│               └── utils
│                   └── JwtUtil.java
├── resources
│   ├── README.md
│   ├── application.properties
│   ├── schema.sql
│   ├── static
│   │   ├── food_form.html
│   │   ├── foods.html
│   │   └── index.html
│   └── templates
│       ├── food_form.html
│       ├── foods.html
│       └── foods_db.html
└── scala
    └── com
        └── ece651
            └── diettracker
                └── recommender
                    └── MealPlanner.scala

21 directories, 32 files
以下是你的回答应该严格遵守的格式:
Present a complete plan to solve the problem and implement it in the codebase.

At the end of your response, respond with the following XML section (if applicable).

以下是要求:
XML Section:

Do not get lazy. Always output the full code in the XML section.
Enclose this entire section in a markdown codeblock
Include all of the changed files
Specify each file operation with CREATE, UPDATE, or DELETE
For CREATE or UPDATE operations, include the full file code
Include the full file path (relative to the project directory, good: app/page.tsx, bad: /Users/mckaywrigley/Desktop/projects/new-chat-template/app/page.tsx)
Enclose the code with ![CDATA[CODE HERE]]
Use the following XML structure:
<code_changes>
  <changed_files>
    <file>
      <file_operation>__FILE OPERATION HERE__</file_operation>
      <file_path>__FILE PATH HERE__</file_path>
      <file_code><![CDATA[
__FULL FILE CODE HERE__
]]></file_code>
    </file>
    __REMAINING FILES HERE__
  </changed_files>
</code_changes>
Other rules:

DO NOT remove <ai_context> sections. These are to provide you additional context about each file.
If you create a file, add an <ai_context> comment section at the top of the file.
If you update a file make sure its <ai_context> stays up-to-date
DO NOT add comments related to your edits
DO NOT remove my existing comments
We may go back and forth a few times. If we do, remember to continue to output the entirety of the code in an XML section (if applicable).

Take all the time you need.
以下是我项目中你的回答需要参考并潜在修改的代码文件:

./src/main/java/com/example/diettracker/repository/FoodRepository.java
package com.example.diettracker.repository;

import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.stereotype.Repository;

import com.example.diettracker.model.Food;
import java.util.List;

@Repository
public interface FoodRepository extends JpaRepository<Food, Long> {
    List<Food> findByFood(String food);
}
./src/main/java/com/example/diettracker/repository/UserRepository.java
package com.example.diettracker.repository;

import com.example.diettracker.model.User;
import org.springframework.data.jpa.repository.JpaRepository;

import java.util.Optional;

public interface UserRepository extends JpaRepository<User, Long> {
    Optional<User> findByUsername(String username);

    Optional<User> findByEmail(String email);
}
./src/main/java/com/example/diettracker/security/SecurityConfig.java
package com.example.diettracker.security;

import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.http.HttpMethod;
import org.springframework.security.config.Customizer;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.http.SessionCreationPolicy;
// Spring Security FilterChain
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.web.cors.CorsConfiguration;
import org.springframework.web.cors.CorsConfigurationSource;
import org.springframework.web.cors.UrlBasedCorsConfigurationSource;

@Configuration
public class SecurityConfig {

    private final JwtAuthenticationFilter jwtAuthenticationFilter;

    /**
     * 构造注入JwtAuthenticationFilter
     * 也可以用 @Autowired 方式
     */
    public SecurityConfig(JwtAuthenticationFilter jwtAuthenticationFilter) {
        this.jwtAuthenticationFilter = jwtAuthenticationFilter;
    }

    /**
     * 核心的安全过滤器链配置
     */
    @Bean
    public SecurityFilterChain securityFilterChain(HttpSecurity http) throws Exception {
        http
                // 1. (可选) 关闭csrf, 前后端分离常用
                .csrf(csrf -> csrf.disable())

                // 2. 配置 CORS 来源 (Spring Security自带的cors)
                .cors(cors -> cors.configurationSource(corsConfigurationSource()))

                // 3. 鉴权配置
                .authorizeHttpRequests(auth -> auth
                        // 3.1 放行 OPTIONS 预检请求，以便浏览器跨域预检
                        .requestMatchers(HttpMethod.OPTIONS, "/**").permitAll()

                        // 3.2 对注册/登录接口放行
                        .requestMatchers("/api/auth/register", "/api/auth/login").permitAll()

                        // 3.3 允许访问静态资源
                        .requestMatchers("/", "/index.html", "/css/**", "/js/**", "/images/**").permitAll()

                        // 3.4 允许访问meal API
                        .requestMatchers("/api/meal/**").permitAll()

                        // 3.5 明确允许访问推荐API
                        .requestMatchers("/api/recommend/**").permitAll()

                        // 3.6 其它接口需要登录访问
                        .anyRequest().authenticated())

                // 4. 不创建Session (不使用HttpSession存储SecurityContext)
                .sessionManagement(session -> session.sessionCreationPolicy(SessionCreationPolicy.STATELESS))

                // 5. 把自定义的 JWT 过滤器放到 UsernamePasswordAuthenticationFilter 之前
                .addFilterBefore(jwtAuthenticationFilter,
                        org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter.class);

        return http.build();
    }

    /**
     * 统一配置 CORS
     */
    @Bean
    public CorsConfigurationSource corsConfigurationSource() {
        CorsConfiguration configuration = new CorsConfiguration();

        // 允许的来源(你前端的URL)
        configuration.addAllowedOrigin("http://localhost:5173");
        // 添加允许localhost:1080访问
        configuration.addAllowedOrigin("http://localhost:1080");
        // 添加允许localhost:8080访问
        configuration.addAllowedOrigin("http://localhost:8080");
        // 如果可能有其他端口，也可以加多个
        configuration.addAllowedOriginPattern("http://localhost:[*]");

        // 允许携带cookie
        configuration.setAllowCredentials(true);

        // 允许的方法
        configuration.addAllowedMethod("GET");
        configuration.addAllowedMethod("POST");
        configuration.addAllowedMethod("PUT");
        configuration.addAllowedMethod("DELETE");
        configuration.addAllowedMethod("OPTIONS");

        // 允许的请求头
        configuration.addAllowedHeader("*");

        // 暴露Authorization头给前端
        configuration.addExposedHeader("Authorization");

        // 注册生效
        UrlBasedCorsConfigurationSource source = new UrlBasedCorsConfigurationSource();
        // 所有路径都应用该配置
        source.registerCorsConfiguration("/**", configuration);

        return source;
    }
}./src/main/java/com/example/diettracker/security/JwtAuthenticationFilter.java
package com.example.diettracker.security;

import com.example.diettracker.utils.JwtUtil;
import io.jsonwebtoken.JwtException;
import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.authority.SimpleGrantedAuthority;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import java.io.IOException;
import java.util.List;

/**
 * Custom JWT validation filter:
 * 1. Parse JWT from request header
 * 2. Validate JWT
 * 3. If validation passes, put user info into SecurityContext
 */
@Component
public class JwtAuthenticationFilter extends OncePerRequestFilter {

    // Assume token is in "Authorization" header with "Bearer " prefix
    private static final String TOKEN_PREFIX = "Bearer ";

    @Override
    protected void doFilterInternal(HttpServletRequest request,
            HttpServletResponse response,
            FilterChain filterChain)
            throws ServletException, IOException {

        // 1. Get Authorization header
        String authorizationHeader = request.getHeader("Authorization");

        // 2. If null or doesn't start with Bearer, proceed (could be anonymous request)
        if (authorizationHeader == null || !authorizationHeader.startsWith(TOKEN_PREFIX)) {
            filterChain.doFilter(request, response);
            return;
        }

        // 3. Extract token
        String token = authorizationHeader.substring(TOKEN_PREFIX.length());

        try {
            // 4. Validate token
            if (JwtUtil.validateToken(token)) {
                // 4.1 Get username
                String username = JwtUtil.parseToken(token);

                // 4.2 Build authorities (for demonstration, just giving ROLE_USER)
                List<SimpleGrantedAuthority> authorities = List.of(new SimpleGrantedAuthority("ROLE_USER"));

                // 4.3 Create Spring Security authentication object and set in context
                UsernamePasswordAuthenticationToken authentication = new UsernamePasswordAuthenticationToken(username,
                        null, authorities);
                SecurityContextHolder.getContext().setAuthentication(authentication);
            }
        } catch (JwtException e) {
            // Invalid token, continue filter chain or return 401 (depending on
            // requirements)
            // For demo: continue, but could use response.sendError(401, "Invalid token");
        }

        // Continue to next filter
        filterChain.doFilter(request, response);
    }
}./src/main/java/com/example/diettracker/DietTrackerApplication.java
package com.example.diettracker;

import org.springframework.boot.SpringApplication;
import org.springframework.boot.autoconfigure.SpringBootApplication;

@SpringBootApplication
public class DietTrackerApplication {
    public static void main(String[] args) {
        SpringApplication.run(DietTrackerApplication.class, args);
    }
}
./src/main/java/com/example/diettracker/utils/JwtUtil.java
package com.example.diettracker.utils;

import io.jsonwebtoken.*;
import java.util.Date;

public class JwtUtil {

    private static final String SECRET_KEY = "TnV0cmlNYXRyaXg=";
    private static final long EXPIRATION_TIME = 1000 * 60 * 60; // 1h

    public static String generateToken(String username) {
        return Jwts.builder()
                .setSubject(username)
                .setIssuedAt(new Date())
                .setExpiration(new Date(System.currentTimeMillis() + EXPIRATION_TIME))
                .signWith(SignatureAlgorithm.HS256, SECRET_KEY)
                .compact();
    }

    public static String parseToken(String token) {
        return Jwts.parser()
                .setSigningKey(SECRET_KEY)
                .parseClaimsJws(token)
                .getBody().getSubject();
    }

    public static boolean validateToken(String token) {
        try {
            Jwts.parser().setSigningKey(SECRET_KEY).parseClaimsJws(token);
            return true;
        } catch (JwtException e) {
            return false;
        }
    }
}
./src/main/java/com/example/diettracker/controller/AuthController.java
package com.example.diettracker.controller;

import com.example.diettracker.model.User;
import com.example.diettracker.service.impl.AuthServiceImpl;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
@RestController
@RequestMapping("/api/auth")
public class AuthController {

    @Autowired
    private AuthServiceImpl authServiceImpl;

    @PostMapping("/register")
    public String register(@RequestBody User user) {
        return authServiceImpl.register(user);
    }

    @PostMapping("/login")
    public String login(@RequestBody User loginUser) {
        return authServiceImpl.login(loginUser);
    }

    // @GetMapping("/test") // only for postman testing
    // public String test() {
    // return "Test!";
    // }
}
./src/main/java/com/example/diettracker/controller/FoodController.java
package com.example.diettracker.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.*;
import com.example.diettracker.model.Food;
import com.example.diettracker.repository.FoodRepository;
import com.example.diettracker.service.FoodService;
import java.util.List;

@RestController
@RequestMapping("/api/foods")
public class FoodController {

    @Autowired
    private FoodService foodService;

    @Autowired
    private FoodRepository foodRepository;

    // RESTful API 接口 - 获取所有食品
    @GetMapping("/all")
    public List<Food> getAllFoodsApi() {
        System.out.println("DEBUG: /api/foods/all endpoint accessed");
        return foodRepository.findAll();
    }

    // RESTful API 接口 - 根据ID获取食品
    @GetMapping("/{id}")
    public Food getFoodById(@PathVariable Long id) {
        return foodService.getFoodById(id)
                .orElseThrow(() -> new RuntimeException("Food not found with id " + id));
    }

    // RESTful API 接口 - 创建食品
    @PostMapping
    public Food createFood(@RequestBody Food food) {
        return foodService.saveFood(food);
    }

    // RESTful API 接口 - 更新食品
    @PutMapping("/{id}")
    public Food updateFood(@PathVariable Long id, @RequestBody Food foodDetails) {
        Food food = foodService.getFoodById(id)
                .orElseThrow(() -> new RuntimeException("Food not found with id " + id));

        food.setFood(foodDetails.getFood());
        food.setCaloricValue(foodDetails.getCaloricValue());
        food.setProtein(foodDetails.getProtein());
        food.setCarbohydrates(foodDetails.getCarbohydrates());
        food.setFat(foodDetails.getFat());

        return foodService.updateFood(food);
    }

    // RESTful API 接口 - 删除食品
    @DeleteMapping("/{id}")
    public void deleteFood(@PathVariable Long id) {
        foodService.deleteFood(id);
    }
}./src/main/java/com/example/diettracker/controller/MealPlanController.java
package com.example.diettracker.controller;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.web.bind.annotation.GetMapping;
import org.springframework.web.bind.annotation.PostMapping;
import org.springframework.web.bind.annotation.RequestBody;
import org.springframework.web.bind.annotation.RequestParam;
import org.springframework.web.bind.annotation.RestController;
import com.example.diettracker.service.MealPlanService;
import java.util.List;
import org.springframework.http.ResponseEntity;
import org.springframework.http.HttpStatus;

@RestController
public class MealPlanController {

    @Autowired
    private MealPlanService mealPlanService;

    /**
     * 获取餐饮计划（GET方法）
     * 接收简单的卡路里参数
     */
    @GetMapping({ "/api/recommend", "/api/meal/recommend" })
    public ResponseEntity<?> getMealPlan(
            @RequestParam(value = "calorieTarget", defaultValue = "2000") double calorieTarget) {
        System.out.println("GET Request received: calorieTarget = " + calorieTarget);
        return processMealPlanRequest(calorieTarget);
    }

    /**
     * 获取餐饮计划（POST方法）
     * 接收JSON请求体，包含卡路里目标
     */
    @PostMapping({ "/api/recommend", "/api/meal/recommend" })
    public ResponseEntity<?> postMealPlan(@RequestBody MealPlanRequest request) {
        System.out.println("POST Request received: calorieTarget = " + request.getCalorieTarget());
        return processMealPlanRequest(request.getCalorieTarget());
    }

    /**
     * 处理餐饮计划请求的通用方法
     */
    private ResponseEntity<?> processMealPlanRequest(double calorieTarget) {
        try {
            List<List<String>> mealPlan = mealPlanService.mealPlanRecommendation(calorieTarget);
            if (mealPlan == null) {
                System.out.println("Final recommendation: No feasible solution found");
            } else if (mealPlan.isEmpty()) {
                System.out.println("Final recommendation: Empty list");
            } else {
                System.out.println("Final recommendation: 1 complete meal plan");
                System.out.println("  Breakfast: " + String.join(", ", mealPlan.get(0)));
                System.out.println("  Lunch: " + String.join(", ", mealPlan.get(1)));
                System.out.println("  Dinner: " + String.join(", ", mealPlan.get(2)));
            }

            if (mealPlan != null && !mealPlan.isEmpty()) {
                return ResponseEntity.ok(mealPlan);
            } else {
                System.out.println("Response to client: No feasible solution");
                return ResponseEntity.status(HttpStatus.NOT_FOUND)
                        .body("No feasible meal plan found for the given constraints.");
            }
        } catch (Exception e) {
            System.out.println("Exception occurred while processing request: " + e.getMessage());
            e.printStackTrace();
            return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR)
                    .body("Error occurred while processing request: " + e.getMessage());
        }
    }

    // 餐饮计划请求体类
    public static class MealPlanRequest {
        private double calorieTarget = 2000; // 默认值为2000卡路里

        // 无参构造器
        public MealPlanRequest() {
        }

        // 带参数构造器
        public MealPlanRequest(double calorieTarget) {
            this.calorieTarget = calorieTarget;
        }

        public double getCalorieTarget() {
            return calorieTarget;
        }

        public void setCalorieTarget(double calorieTarget) {
            this.calorieTarget = calorieTarget;
        }
    }

    // Add a simple test endpoint
    @GetMapping("/api/recommend/test")
    public String test() {
        return "API working normally!";
    }
}
./src/main/java/com/example/diettracker/model/User_old.java
// package com.example.diettracker.model;

// import jakarta.persistence.*;

// @Entity
// @Table(name = "users")
// public class User {
//     @Id
//     @GeneratedValue(strategy = GenerationType.IDENTITY)
//     private Long id;
    
//     @Column(unique = true, nullable = false)
//     private String username;
    
//     @Column(unique = true, nullable = false)
//     private String email;
    
//     @Column(nullable = false)
//     private String password;
    
//     // Getter and Setter methods
    
//     public Long getId() {
//         return id;
//     }
    
//     public void setId(Long id) {
//         this.id = id;
//     }
    
//     public String getUsername() {
//         return username;
//     }
    
//     public void setUsername(String username) {
//         this.username = username;
//     }
    
//     public String getEmail() {
//         return email;
//     }
    
//     public void setEmail(String email) {
//         this.email = email;
//     }
    
//     public String getPassword() {
//         return password;
//     }
    
//     public void setPassword(String password) {
//         this.password = password;
//     }
    
//     // Constructors
    
//     public User() {
//     }
    
//     public User(Long id, String username, String email, String password) {
//         this.id = id;
//         this.username = username;
//         this.email = email;
//         this.password = password;
//     }
// }./src/main/java/com/example/diettracker/model/DietDailyInput.java
package com.example.diettracker.model;

import jakarta.persistence.*;
import java.util.Date;
import java.sql.Time;

@Entity
@Table(name = "Diet_Daily_Input")
public class DietDailyInput {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer dietID;

    @ManyToOne
    @JoinColumn(name = "userID", nullable = false)
    private User user;

    @ManyToOne
    @JoinColumn(name = "foodID", nullable = false)
    private Food food;

    @Column(nullable = false)
    private String dietType;

    @Column(nullable = false)
    private Integer calories;

    @Column(nullable = false)
    private Time time;

    @Column(nullable = false)
    @Temporal(TemporalType.DATE)
    private Date date;

    // Default constructor
    public DietDailyInput() {
    }

    // Constructor with fields
    public DietDailyInput(User user, Food food, String dietType, Integer calories, 
                          Time time, Date date) {
        this.user = user;
        this.food = food;
        this.dietType = dietType;
        this.calories = calories;
        this.time = time;
        this.date = date;
    }

    // Getters and Setters
    public Integer getDietID() {
        return dietID;
    }

    public void setDietID(Integer dietID) {
        this.dietID = dietID;
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

    public Food getFood() {
        return food;
    }

    public void setFood(Food food) {
        this.food = food;
    }

    public String getDietType() {
        return dietType;
    }

    public void setDietType(String dietType) {
        this.dietType = dietType;
    }

    public Integer getCalories() {
        return calories;
    }

    public void setCalories(Integer calories) {
        this.calories = calories;
    }

    public Time getTime() {
        return time;
    }

    public void setTime(Time time) {
        this.time = time;
    }

    public Date getDate() {
        return date;
    }

    public void setDate(Date date) {
        this.date = date;
    }
}./src/main/java/com/example/diettracker/model/Recommendation.java
package com.example.diettracker.model;

import jakarta.persistence.*;

@Entity
@Table(name = "Recommendation")
public class Recommendation {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer recomID;

    @ManyToOne
    @JoinColumn(name = "userID", nullable = false)
    private User user;

    @ManyToOne
    @JoinColumn(name = "foodID", nullable = false)
    private Food food;

    @Column(nullable = false)
    private String dietType;

    // Default constructor
    public Recommendation() {
    }

    // Constructor with fields
    public Recommendation(User user, Food food, String dietType) {
        this.user = user;
        this.food = food;
        this.dietType = dietType;
    }

    // Getters and Setters
    public Integer getRecomID() {
        return recomID;
    }

    public void setRecomID(Integer recomID) {
        this.recomID = recomID;
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

    public Food getFood() {
        return food;
    }

    public void setFood(Food food) {
        this.food = food;
    }

    public String getDietType() {
        return dietType;
    }

    public void setDietType(String dietType) {
        this.dietType = dietType;
    }
}./src/main/java/com/example/diettracker/model/WeightInput.java
package com.example.diettracker.model;

import jakarta.persistence.*;
import java.util.Date;
import java.sql.Time;

@Entity
@Table(name = "Weight_input")
public class WeightInput {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;

    @ManyToOne
    @JoinColumn(name = "userID", nullable = false)
    private User user;

    @Column(nullable = false)
    @Temporal(TemporalType.DATE)
    private Date date;

    @Column(nullable = false)
    private Time time;

    @Column(nullable = false)
    private String input;  // Using TYPE as field name might conflict with Java keywords

    // Default constructor
    public WeightInput() {
    }

    // Constructor with fields
    public WeightInput(User user, Date date, Time time, String input) {
        this.user = user;
        this.date = date;
        this.time = time;
        this.input = input;
    }

    // Getters and Setters
    public Integer getId() {
        return id;
    }

    public void setId(Integer id) {
        this.id = id;
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }

    public Date getDate() {
        return date;
    }

    public void setDate(Date date) {
        this.date = date;
    }

    public Time getTime() {
        return time;
    }

    public void setTime(Time time) {
        this.time = time;
    }

    public String getInput() {
        return input;
    }

    public void setInput(String input) {
        this.input = input;
    }
}./src/main/java/com/example/diettracker/model/User.java
package com.example.diettracker.model;

import jakarta.persistence.*;

@Entity
@Table(name = "User")
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer userID;

    @Column(nullable = false)
    private String username;

    @Column(nullable = false)
    private String password;

    @Column(nullable = false)
    private String email;

    private Integer age;
    private Integer weight;
    private Integer height;
    private Integer idealWeight;

    // Default constructor
    public User() {
    }

    // Constructor with fields
    public User(String username, String password, String email, Integer age, 
                Integer weight, Integer height, Integer idealWeight) {
        this.username = username;
        this.password = password;
        this.email = email;
        this.age = age;
        this.weight = weight;
        this.height = height;
        this.idealWeight = idealWeight;
    }

    // Getters and Setters
    public Integer getUserID() {
        return userID;
    }

    public void setUserID(Integer userID) {
        this.userID = userID;
    }

    public String getUsername() {
        return username;
    }

    public void setUsername(String username) {
        this.username = username;
    }

    public String getPassword() {
        return password;
    }

    public void setPassword(String password) {
        this.password = password;
    }

    public String getEmail() {
        return email;
    }

    public void setEmail(String email) {
        this.email = email;
    }

    public Integer getAge() {
        return age;
    }

    public void setAge(Integer age) {
        this.age = age;
    }

    public Integer getWeight() {
        return weight;
    }

    public void setWeight(Integer weight) {
        this.weight = weight;
    }

    public Integer getHeight() {
        return height;
    }

    public void setHeight(Integer height) {
        this.height = height;
    }

    public Integer getIdealWeight() {
        return idealWeight;
    }

    public void setIdealWeight(Integer idealWeight) {
        this.idealWeight = idealWeight;
    }
}./src/main/java/com/example/diettracker/model/Food.java
package com.example.diettracker.model;

import jakarta.persistence.*;

@Entity
@Table(name = "food_nutrition")
public class Food {

    @Id
    // Automatically generate primary key in database
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    private String food;
    // @Column(name = "Caloric_Value") add this if the case change gives errors
    private int caloricValue;
    private double fat;
    private double saturatedFats;
    private double monounsaturatedFats;
    private double polyunsaturatedFats;
    private double carbohydrates;
    private double sugars;
    private double protein;
    private double dietaryFiber;
    private double cholesterol;
    private double sodium;
    private double water;
    private double vitaminA;
    private double vitaminB1;
    private double vitaminB11;
    private double vitaminB12;
    private double vitaminB2;
    private double vitaminB3;
    private double vitaminB5;
    private double vitaminB6;
    private double vitaminC;
    private double vitaminD;
    private double vitaminE;
    private double vitaminK;
    private double calcium;
    private double copper;
    private double iron;
    private double magnesium;
    private double manganese;
    private double phosphorus;
    private double potassium;
    private double selenium;
    private double zinc;
    private double nutritionDensity;
    private String category;

    public Food() {
    }

    public Food(String name, int caloricValue, double fat, double saturatedFats, double monounsaturatedFats,
            double polyunsaturatedFats,
            double carbohydrates, double sugars, double protein, double dietaryFiber, double cholesterol, double sodium,
            double water, double vitaminA, double vitaminB1, double vitaminB11, double vitaminB12, double vitaminB2,
            double vitaminB3,
            double vitaminB5, double vitaminB6, double vitaminC, double vitaminD, double vitaminE, double vitaminK,
            double calcium,
            double copper, double iron, double magnesium, double manganese, double phosphorus, double potassium,
            double selenium,
            double zinc, double nutritionDensity, String category) {
        this.food = name;
        this.caloricValue = caloricValue;
        this.fat = fat;
        this.saturatedFats = saturatedFats;
        this.monounsaturatedFats = monounsaturatedFats;
        this.polyunsaturatedFats = polyunsaturatedFats;
        this.carbohydrates = carbohydrates;
        this.sugars = sugars;
        this.protein = protein;
        this.dietaryFiber = dietaryFiber;
        this.cholesterol = cholesterol;
        this.sodium = sodium;
        this.water = water;
        this.vitaminA = vitaminA;
        this.vitaminB1 = vitaminB1;
        this.vitaminB11 = vitaminB11;
        this.vitaminB12 = vitaminB12;
        this.vitaminB2 = vitaminB2;
        this.vitaminB3 = vitaminB3;
        this.vitaminB5 = vitaminB5;
        this.vitaminB6 = vitaminB6;
        this.vitaminC = vitaminC;
        this.vitaminD = vitaminD;
        this.vitaminE = vitaminE;
        this.vitaminK = vitaminK;
        this.calcium = calcium;
        this.copper = copper;
        this.iron = iron;
        this.magnesium = magnesium;
        this.manganese = manganese;
        this.phosphorus = phosphorus;
        this.potassium = potassium;
        this.selenium = selenium;
        this.zinc = zinc;
        this.nutritionDensity = nutritionDensity;
        this.category = category;

    }

    // add more getter and setter if I missed some

    public Long getId() {
        return id;
    }

    public String getFood() {
        return food;
    }

    public int getCaloricValue() {
        return caloricValue;
    }

    public void setCaloricValue(int caloricValue) {
        this.caloricValue = caloricValue;
    }

    public double getNutritionDensity() {
        return nutritionDensity;
    }

    public void setNutritionDensity(double nutritionDensity) {
        this.nutritionDensity = nutritionDensity;
    }

    public void setFood(String name) {
        this.food = name;
    }

    public double getFat() {
        return fat;
    }

    public void setFat(double fat) {
        this.fat = fat;
    }

    public double getSaturatedFats() {
        return saturatedFats;
    }

    public void setSaturatedFats(double saturatedFats) {
        this.saturatedFats = saturatedFats;
    }

    public double getMonounsaturatedFats() {
        return monounsaturatedFats;
    }

    public void setMonounsaturatedFats(double monounsaturatedFats) {
        this.monounsaturatedFats = monounsaturatedFats;
    }

    public double getPolyunsaturatedFats() {
        return polyunsaturatedFats;
    }

    public void setPolyunsaturatedFats(double polyunsaturatedFats) {
        this.polyunsaturatedFats = polyunsaturatedFats;
    }

    public double getCarbohydrates() {
        return carbohydrates;
    }

    public void setCarbohydrates(double carbohydrates) {
        this.carbohydrates = carbohydrates;
    }

    public double getSugars() {
        return sugars;
    }

    public void setSugars(double sugars) {
        this.sugars = sugars;
    }

    public double getProtein() {
        return protein;
    }

    public void setProtein(double protein) {
        this.protein = protein;
    }

    public double getDietaryFiber() {
        return dietaryFiber;
    }

    public void setDietaryFiber(double dietaryFiber) {
        this.dietaryFiber = dietaryFiber;
    }

    public double getCholesterol() {
        return cholesterol;
    }

    public void setCholesterol(double cholesterol) {
        this.cholesterol = cholesterol;
    }

    public double getSodium() {
        return sodium;
    }

    public void setSodium(double sodium) {
        this.sodium = sodium;
    }

    public double getWater() {
        return water;
    }

    public void setWater(double water) {
        this.water = water;
    }

    public double getVitaminA() {
        return vitaminA;
    }

    public void setVitaminA(double vitaminA) {
        this.vitaminA = vitaminA;
    }

    public double getVitaminB1() {
        return vitaminB1;
    }

    public void setVitaminB1(double vitaminB1) {
        this.vitaminB1 = vitaminB1;
    }

    public double getVitaminB11() {
        return vitaminB11;
    }

    public void setVitaminB11(double vitaminB11) {
        this.vitaminB11 = vitaminB11;
    }

    public double getVitaminB12() {
        return vitaminB12;
    }

    public void setVitaminB12(double vitaminB12) {
        this.vitaminB12 = vitaminB12;
    }

    public double getVitaminB2() {
        return vitaminB2;
    }

    public void setVitaminB2(double vitaminB2) {
        this.vitaminB2 = vitaminB2;
    }

    public double getVitaminB3() {
        return vitaminB3;
    }

    public void setVitaminB3(double vitaminB3) {
        this.vitaminB3 = vitaminB3;
    }

    public double getVitaminB5() {
        return vitaminB5;
    }

    public void setVitaminB5(double vitaminB5) {
        this.vitaminB5 = vitaminB5;
    }

    public double getVitaminB6() {
        return vitaminB6;
    }

    public void setVitaminB6(double vitaminB6) {
        this.vitaminB6 = vitaminB6;
    }

    public double getVitaminC() {
        return vitaminC;
    }

    public void setVitaminC(double vitaminC) {
        this.vitaminC = vitaminC;
    }

    public double getVitaminD() {
        return vitaminD;
    }

    public void setVitaminD(double vitaminD) {
        this.vitaminD = vitaminD;
    }

    public double getVitaminE() {
        return vitaminE;
    }

    public void setVitaminE(double vitaminE) {
        this.vitaminE = vitaminE;
    }

    public double getVitaminK() {
        return vitaminK;
    }

    public void setVitaminK(double vitaminK) {
        this.vitaminK = vitaminK;
    }

    public double getCalcium() {
        return calcium;
    }

    public void setCalcium(double calcium) {
        this.calcium = calcium;
    }

    public double getCopper() {
        return copper;
    }

    public void setCopper(double copper) {
        this.copper = copper;
    }

    public double getIron() {
        return iron;
    }

    public void setIron(double iron) {
        this.iron = iron;
    }

    public double getMagnesium() {
        return magnesium;
    }

    public void setMagnesium(double magnesium) {
        this.magnesium = magnesium;
    }

    public double getManganese() {
        return manganese;
    }

    public void setManganese(double manganese) {
        this.manganese = manganese;
    }

    public double getPhosphorus() {
        return phosphorus;
    }

    public void setPhosphorus(double phosphorus) {
        this.phosphorus = phosphorus;
    }

    public double getPotassium() {
        return potassium;
    }

    public void setPotassium(double potassium) {
        this.potassium = potassium;
    }

    public double getSelenium() {
        return selenium;
    }

    public void setSelenium(double selenium) {
        this.selenium = selenium;
    }

    public double getZinc() {
        return zinc;
    }

    public void setZinc(double zinc) {
        this.zinc = zinc;
    }

    public String getCategory() {
        return category;
    }

    public void setCategory(String category) {
        this.category = category;
    }

}
./src/main/java/com/example/diettracker/model/SetGoal.java
package com.example.diettracker.model;

import jakarta.persistence.*;

@Entity
@Table(name = "SetGoal")
public class SetGoal {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer goalID;

    @Column(nullable = false)
    private String goalType;

    private Integer formulaID;

    @ManyToOne
    @JoinColumn(name = "goalID", insertable = false, updatable = false)
    private User user;

    // Default constructor
    public SetGoal() {
    }

    // Constructor with fields
    public SetGoal(String goalType, Integer formulaID) {
        this.goalType = goalType;
        this.formulaID = formulaID;
    }

    // Getters and Setters
    public Integer getGoalID() {
        return goalID;
    }

    public void setGoalID(Integer goalID) {
        this.goalID = goalID;
    }

    public String getGoalType() {
        return goalType;
    }

    public void setGoalType(String goalType) {
        this.goalType = goalType;
    }

    public Integer getFormulaID() {
        return formulaID;
    }

    public void setFormulaID(Integer formulaID) {
        this.formulaID = formulaID;
    }

    public User getUser() {
        return user;
    }

    public void setUser(User user) {
        this.user = user;
    }
}./src/main/java/com/example/diettracker/filter/TokenFilter.java
// package com.example.diettracker.filter;

// import jakarta.servlet.*;
// import jakarta.servlet.annotation.WebFilter;
// import jakarta.servlet.http.HttpServletRequest;
// import jakarta.servlet.http.HttpServletResponse;
// import com.example.diettracker.utils.JwtUtil;
// import java.io.IOException;

// @WebFilter(urlPatterns = "/*")
// public class TokenFilter implements Filter {

//     @Override
//     public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain)
//             throws IOException, ServletException {
//         HttpServletRequest req = (HttpServletRequest) request;
//         HttpServletResponse res = (HttpServletResponse) response;

//         // 如果是预检 OPTIONS 请求，直接放行
//         if ("OPTIONS".equalsIgnoreCase(req.getMethod())) {
//             chain.doFilter(request, response);
//             return;
//         }

//         String uri = req.getRequestURI();

//         // 对注册和登录接口放行（注意如果接口路径包含/api/auth/register，要一起判断）
//         if (uri.equals("/register") || uri.equals("/login")
//                 || uri.equals("/api/auth/register") || uri.equals("/api/auth/login")) {
//             chain.doFilter(request, response);
//             return;
//         }

//         String token = req.getHeader("token");
//         if (token == null || token.isEmpty() || !JwtUtil.validateToken(token)) {
//             res.setStatus(401);
//             return;
//         }

//         chain.doFilter(request, response);
//     }
// }./src/main/java/com/example/diettracker/service/impl/AuthServiceImpl.java
package com.example.diettracker.service.impl;

import com.example.diettracker.model.User;
import com.example.diettracker.service.AuthService;
import com.example.diettracker.repository.UserRepository;
import com.example.diettracker.utils.JwtUtil;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.Optional;

@Service
public class AuthServiceImpl implements AuthService {

    @Autowired
    private UserRepository userRepository;

    @Override
    public String register(User user) { // registration service
        if (userRepository.findByEmail(user.getEmail()).isPresent()) {
            return "Email has been taken";
        }
        if (userRepository.findByUsername(user.getUsername()).isPresent()) {
            return "Username already taken!";
        }
        userRepository.save(user);
        return "New user registered successfully!";
    }

    @Override
    // login service
    //User can login in by username or email
    public String login(User loginUser) {
        Optional<User> user = userRepository.findByUsername(loginUser.getUsername())
                .or(() -> userRepository.findByEmail(loginUser.getUsername()));

        if (user.isEmpty() || !user.get().getPassword().equals(loginUser.getPassword())) {
            return "Invalid credentials!";
        }

        return "login successfully!" + JwtUtil.generateToken(loginUser.getUsername());
    }
}
./src/main/java/com/example/diettracker/service/AuthService.java
package com.example.diettracker.service;

import com.example.diettracker.model.User;

public interface AuthService {
    /**
     * user registration
     */
    String register(User user);

    /**
     * user login
     */
    String login(User user);
}
./src/main/java/com/example/diettracker/service/MealPlanService.java
package com.example.diettracker.service;

import com.example.diettracker.model.Food;
import com.example.diettracker.repository.FoodRepository;
import com.google.ortools.linearsolver.MPConstraint;
import com.google.ortools.linearsolver.MPObjective;
import com.google.ortools.linearsolver.MPSolver;
import com.google.ortools.linearsolver.MPSolver.ResultStatus;
import com.google.ortools.linearsolver.MPVariable;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import java.util.ArrayList;
import java.util.Collections;
import java.util.List;
import java.util.Random;
import java.util.stream.Collectors;

/**
 * 确保在项目中已加载 OR-Tools 的 native 动态库,
 * 例如在 main 函数或配置类中调用: Loader.loadNativeLibraries();
 */

/*
 * Min: |protein_ratio - 0.3| + |carbs_ratio - 0.2| + |fat_ratio - 0.5| +
 * 0.1 * Σ(meat_repeat_penalty) +
 * 0.1 * Σ(veg_repeat_penalty) +
 * 0.1 * Σ(carb_repeat_penalty)
 */
@Service
public class MealPlanService {

    @Autowired
    private FoodRepository foodRepository;

    private static final int[] MEALS = { 0, 1, 2 }; // 三餐编码: 0=早餐,1=午餐,2=晚餐
    // private static final double[] MEAL_RATIOS = { 0.3, 0.4, 0.3 }; //
    // 对应三餐在总卡路里中的比例
    private static final double ALPHA = 0.1; // 重复使用的惩罚系数(示例)
    private static final double TARGET_PROTEIN_RATIO = 0.3; // 蛋白质占比 30%
    private static final double TARGET_CARBS_RATIO = 0.2; // 碳水占比 20%
    private static final double TARGET_FAT_RATIO = 0.5; // 脂肪占比 50%

    /**
     * 主入口：根据用户给定的卡路里需求，返回三餐食物列表 (每餐 [meat, veg, carb])。
     * 若无解，返回 null。
     */
    public List<List<String>> mealPlanRecommendation(double calorieTarget) {
        // 1. 从数据库中读取全部食物
        List<Food> allFoods = foodRepository.findAll();

        // 添加调试信息
        System.out.println("Current food database size: " + allFoods.size());

        // 根据 categoryPred 分组
        List<Food> meats = allFoods.stream()
                .filter(f -> "meats".equalsIgnoreCase(f.getCategory()))
                .collect(Collectors.toList());
        List<Food> vegs = allFoods.stream()
                .filter(f -> "vegetables".equalsIgnoreCase(f.getCategory()))
                .collect(Collectors.toList());
        List<Food> carbs = allFoods.stream()
                .filter(f -> "carbs".equalsIgnoreCase(f.getCategory()))
                .collect(Collectors.toList());

        List<Food> others = allFoods.stream()
                .filter(f -> "others".equalsIgnoreCase(f.getCategory()))
                .collect(Collectors.toList());

        // =========== 第一阶段: 只考虑热量约束 ===========
        System.out.println("Stage 1: Simplified optimization, calorieTarget=" + calorieTarget);
        ModelData simplifiedModel = buildSimplifiedProblem(
                meats, vegs, carbs, others,
                calorieTarget,
                noRepeat(true));

        List<List<List<String>>> firstStageSolutions = enumerateSolutions(
                simplifiedModel,
                meats, vegs, carbs, others,
                maxSolutions(3));

        System.out.println("Stage 1 results: Found " + firstStageSolutions.size() + " solutions");

        if (firstStageSolutions.isEmpty()) {
            // 尝试放宽约束 - 允许重复食物
            System.out.println("Attempting to relax Stage 1 constraints - allowing repeated foods");
            simplifiedModel = buildSimplifiedProblem(
                    meats, vegs, carbs, others,
                    calorieTarget,
                    noRepeat(false));
            firstStageSolutions = enumerateSolutions(
                    simplifiedModel,
                    meats, vegs, carbs, others,
                    maxSolutions(3));
            System.out.println("Relaxed constraints Stage 1 results: "
                    + (firstStageSolutions.isEmpty() ? "No solution"
                            : "Found " + firstStageSolutions.size() + " solutions"));
        }

        if (!firstStageSolutions.isEmpty()) {
            // =========== 第二阶段: 基于第一阶段结果优化营养素比例 ===========
            System.out.println("Starting Stage 2 optimization: Nutrient ratios");
            List<List<List<String>>> finalSolutions = new ArrayList<>();

            for (List<List<String>> baselineSolution : firstStageSolutions) {
                // 基于第一阶段解构建完整模型，固定部分食物选择
                ModelData refinedModel = buildDailyMealProblem(
                        meats, vegs, carbs, others,
                        calorieTarget,
                        noRepeat(true),
                        addRepeatPenalty(true),
                        baselineSolution);

                // 求解第二阶段，只需要找一个最优解即可
                List<List<List<String>>> improvedSolutions = enumerateSolutions(
                        refinedModel,
                        meats, vegs, carbs, others,
                        maxSolutions(1));

                if (!improvedSolutions.isEmpty()) {
                    finalSolutions.add(improvedSolutions.get(0));
                    if (finalSolutions.size() >= 3) {
                        break; // 找到足够多的最终解则停止
                    }
                }
            }

            System.out.println("Stage 2 results: Generated " + finalSolutions.size()
                    + " candidate plans, will randomly select 1 as recommendation");

            if (!finalSolutions.isEmpty()) {
                // 随机返回一个解
                Random rand = new Random();
                return finalSolutions.get(rand.nextInt(finalSolutions.size()));
            }
        }

        // 如果两阶段优化失败，回退到原始方法
        System.out.println("Two-stage optimization failed, falling back to single-stage method");
        // (1) 先尝试硬约束 "不重复"
        ModelData modelData1 = buildDailyMealProblem(
                meats, vegs, carbs, others,
                calorieTarget,
                noRepeat(true),
                addRepeatPenalty(false),
                null);
        // 枚举可行解(最多找3个)
        List<List<List<String>>> solutions1 = enumerateSolutions(
                modelData1,
                meats, vegs, carbs, others,
                maxSolutions(3));
        System.out.println("Mode 1 (hard constraint, no repeat) results: "
                + (solutions1.isEmpty() ? "No solution" : "Found " + solutions1.size() + " solutions"));

        if (!solutions1.isEmpty()) {
            // 随机返回一个解
            Random rand = new Random();
            return solutions1.get(rand.nextInt(solutions1.size()));
        }

        // (2) 若无解，改为软约束，允许重复食材但给予重复惩罚
        ModelData modelData2 = buildDailyMealProblem(
                meats, vegs, carbs, others,
                calorieTarget,
                noRepeat(false),
                addRepeatPenalty(true),
                null);
        // 再找3个解
        List<List<List<String>>> solutions2 = enumerateSolutions(
                modelData2,
                meats, vegs, carbs, others,
                maxSolutions(3));
        System.out.println("Mode 2 (soft constraint, penalty for repeated) results: "
                + (solutions2.isEmpty() ? "No solution" : "Found " + solutions2.size() + " solutions"));

        if (!solutions2.isEmpty()) {
            Random rand = new Random();
            return solutions2.get(rand.nextInt(solutions2.size()));
        }

        // (3) 若仍无解，去掉所有重复约束和惩罚
        ModelData modelData3 = buildDailyMealProblem(
                meats, vegs, carbs, others,
                calorieTarget,
                noRepeat(false),
                addRepeatPenalty(false),
                null);
        // 再找3个解
        List<List<List<String>>> solutions3 = enumerateSolutions(
                modelData3,
                meats, vegs, carbs, others,
                maxSolutions(3));
        System.out.println("Mode 3 (no repeat constraint) results: "
                + (solutions3.isEmpty() ? "No solution" : "Found " + solutions3.size() + " solutions"));

        if (!solutions3.isEmpty()) {
            Random rand = new Random();
            return solutions3.get(rand.nextInt(solutions3.size()));
        }

        // 返回空解
        return Collections.emptyList();
    }

    /**
     * 构建第一阶段简化问题 - 只考虑热量约束，不考虑营养素比例
     */
    private ModelData buildSimplifiedProblem(
            List<Food> meats,
            List<Food> vegs,
            List<Food> carbs,
            List<Food> others,
            double calorieTarget,
            boolean noRepeat) {

        MPSolver solver = MPSolver.createSolver("SCIP");
        if (solver == null) {
            System.out.println("SCIP solver not available. Trying alternative solver...");
            solver = MPSolver.createSolver("CBC");
            if (solver == null) {
                System.out.println("CBC solver also not available, cannot continue.");
                return null;
            }
        }

        // 创建决策变量
        MPVariable[][] xMeats = new MPVariable[meats.size()][MEALS.length];
        for (int i = 0; i < meats.size(); i++) {
            for (int m : MEALS) {
                xMeats[i][m] = solver.makeBoolVar("meat_" + i + "_" + m);
            }
        }
        MPVariable[][] xVegs = new MPVariable[vegs.size()][MEALS.length];
        for (int i = 0; i < vegs.size(); i++) {
            for (int m : MEALS) {
                xVegs[i][m] = solver.makeBoolVar("veg_" + i + "_" + m);
            }
        }
        MPVariable[][] xCarbs = new MPVariable[carbs.size()][MEALS.length];
        for (int i = 0; i < carbs.size(); i++) {
            for (int m : MEALS) {
                xCarbs[i][m] = solver.makeBoolVar("carb_" + i + "_" + m);
            }
        }
        MPVariable[] xOthers = new MPVariable[others.size()];
        for (int i = 0; i < others.size(); i++) {
            xOthers[i] = solver.makeBoolVar("other_" + i);
        }

        // 每餐至少选择一种肉类、蔬菜和碳水
        for (int m : MEALS) {
            MPConstraint cMeat = solver.makeConstraint(1, Double.POSITIVE_INFINITY, "min_meat_" + m);
            for (int i = 0; i < meats.size(); i++) {
                cMeat.setCoefficient(xMeats[i][m], 1);
            }

            MPConstraint cVeg = solver.makeConstraint(1, Double.POSITIVE_INFINITY, "min_veg_" + m);
            for (int i = 0; i < vegs.size(); i++) {
                cVeg.setCoefficient(xVegs[i][m], 1);
            }

            MPConstraint cCarb = solver.makeConstraint(1, Double.POSITIVE_INFINITY, "min_carb_" + m);
            for (int i = 0; i < carbs.size(); i++) {
                cCarb.setCoefficient(xCarbs[i][m], 1);
            }
        }

        // 只在午餐中选择一个"others"类别食物
        MPConstraint cOther = solver.makeConstraint(1, 1, "one_other");
        for (int i = 0; i < others.size(); i++) {
            cOther.setCoefficient(xOthers[i], 1);
        }

        // 热量约束: 总热量在目标热量的95%-105%范围内
        MPConstraint cCalLower = solver.makeConstraint(0.95 * calorieTarget, Double.POSITIVE_INFINITY, "cal_lower");
        MPConstraint cCalUpper = solver.makeConstraint(0, 1.05 * calorieTarget, "cal_upper");

        // 添加热量约束系数
        for (int i = 0; i < meats.size(); i++) {
            for (int m : MEALS) {
                cCalLower.setCoefficient(xMeats[i][m], meats.get(i).getCaloricValue());
                cCalUpper.setCoefficient(xMeats[i][m], meats.get(i).getCaloricValue());
            }
        }
        for (int i = 0; i < vegs.size(); i++) {
            for (int m : MEALS) {
                cCalLower.setCoefficient(xVegs[i][m], vegs.get(i).getCaloricValue());
                cCalUpper.setCoefficient(xVegs[i][m], vegs.get(i).getCaloricValue());
            }
        }
        for (int i = 0; i < carbs.size(); i++) {
            for (int m : MEALS) {
                cCalLower.setCoefficient(xCarbs[i][m], carbs.get(i).getCaloricValue());
                cCalUpper.setCoefficient(xCarbs[i][m], carbs.get(i).getCaloricValue());
            }
        }
        for (int i = 0; i < others.size(); i++) {
            cCalLower.setCoefficient(xOthers[i], others.get(i).getCaloricValue());
            cCalUpper.setCoefficient(xOthers[i], others.get(i).getCaloricValue());
        }

        // 不重复约束（如果需要）
        if (noRepeat) {
            // 各类食材不重复使用
            for (int i = 0; i < meats.size(); i++) {
                MPConstraint c = solver.makeConstraint(0, 1, "meat_" + i + "_once");
                for (int m : MEALS) {
                    c.setCoefficient(xMeats[i][m], 1);
                }
            }
            for (int i = 0; i < vegs.size(); i++) {
                MPConstraint c = solver.makeConstraint(0, 1, "veg_" + i + "_once");
                for (int m : MEALS) {
                    c.setCoefficient(xVegs[i][m], 1);
                }
            }
            for (int i = 0; i < carbs.size(); i++) {
                MPConstraint c = solver.makeConstraint(0, 1, "carb_" + i + "_once");
                for (int m : MEALS) {
                    c.setCoefficient(xCarbs[i][m], 1);
                }
            }
        }

        // 目标函数：最小化与目标热量的差距
        MPObjective objective = solver.objective();
        // 创建辅助变量表示与目标热量的差距
        MPVariable calDev = solver.makeNumVar(0, Double.POSITIVE_INFINITY, "cal_deviation");
        MPConstraint cDevCalPos = solver.makeConstraint(0, Double.POSITIVE_INFINITY, "dev_cal_pos");
        MPConstraint cDevCalNeg = solver.makeConstraint(0, Double.POSITIVE_INFINITY, "dev_cal_neg");

        cDevCalPos.setCoefficient(calDev, 1);
        for (int i = 0; i < meats.size(); i++) {
            for (int m : MEALS) {
                cDevCalPos.setCoefficient(xMeats[i][m], -meats.get(i).getCaloricValue());
            }
        }
        for (int i = 0; i < vegs.size(); i++) {
            for (int m : MEALS) {
                cDevCalPos.setCoefficient(xVegs[i][m], -vegs.get(i).getCaloricValue());
            }
        }
        for (int i = 0; i < carbs.size(); i++) {
            for (int m : MEALS) {
                cDevCalPos.setCoefficient(xCarbs[i][m], -carbs.get(i).getCaloricValue());
            }
        }
        for (int i = 0; i < others.size(); i++) {
            cDevCalPos.setCoefficient(xOthers[i], -others.get(i).getCaloricValue());
        }
        // 将偏移量设置为约束的下界
        cDevCalPos.setBounds(calorieTarget, Double.POSITIVE_INFINITY);

        cDevCalNeg.setCoefficient(calDev, 1);
        for (int i = 0; i < meats.size(); i++) {
            for (int m : MEALS) {
                cDevCalNeg.setCoefficient(xMeats[i][m], meats.get(i).getCaloricValue());
            }
        }
        for (int i = 0; i < vegs.size(); i++) {
            for (int m : MEALS) {
                cDevCalNeg.setCoefficient(xVegs[i][m], vegs.get(i).getCaloricValue());
            }
        }
        for (int i = 0; i < carbs.size(); i++) {
            for (int m : MEALS) {
                cDevCalNeg.setCoefficient(xCarbs[i][m], carbs.get(i).getCaloricValue());
            }
        }
        for (int i = 0; i < others.size(); i++) {
            cDevCalNeg.setCoefficient(xOthers[i], others.get(i).getCaloricValue());
        }
        // 将偏移量设置为约束的下界
        cDevCalNeg.setBounds(-calorieTarget, Double.POSITIVE_INFINITY);

        // 优化目标：最小化热量偏差
        objective.setCoefficient(calDev, 1);
        objective.setMinimization();

        return new ModelData(solver, xMeats, xVegs, xCarbs, xOthers);
    }

    /**
     * 构建完整问题，优化营养素比例
     */
    private ModelData buildDailyMealProblem(
            List<Food> meats,
            List<Food> vegs,
            List<Food> carbs,
            List<Food> others,
            double calorieTarget,
            boolean noRepeat,
            boolean addRepeatPenalty,
            List<List<String>> baselineSolution) {
        // 计算可用的食物组合是否能满足卡路里目标
        System.out.println(
                "Building problem: calorieTarget=" + calorieTarget + ", noRepeat=" + noRepeat + ", addRepeatPenalty="
                        + addRepeatPenalty);

        // 1. 创建求解器
        // 注意: "CBC_MIXED_INTEGER_PROGRAMMING" 即使用 CBC 求解整型规划
        MPSolver solver = new MPSolver(
                "DailyMealPlan",
                MPSolver.OptimizationProblemType.CBC_MIXED_INTEGER_PROGRAMMING);

        // 2. 定义 0/1 决策变量 xMeats[i][m], xVegs[i][m], xCarbs[i][m]
        MPVariable[][] xMeats = new MPVariable[meats.size()][MEALS.length];
        MPVariable[][] xVegs = new MPVariable[vegs.size()][MEALS.length];
        MPVariable[][] xCarbs = new MPVariable[carbs.size()][MEALS.length];
        // 添加others类型食物决策变量，仅用于午餐(m=1)
        MPVariable[] xOthers = new MPVariable[others.size()];

        // 初始化变量
        for (int i = 0; i < meats.size(); i++) {
            for (int m : MEALS) {
                xMeats[i][m] = solver.makeBoolVar("meat_" + i + "_meal_" + m);
            }
        }
        for (int i = 0; i < vegs.size(); i++) {
            for (int m : MEALS) {
                xVegs[i][m] = solver.makeBoolVar("veg_" + i + "_meal_" + m);
            }
        }
        for (int i = 0; i < carbs.size(); i++) {
            for (int m : MEALS) {
                xCarbs[i][m] = solver.makeBoolVar("carb_" + i + "_meal_" + m);
            }
        }
        // 初始化others类型食物变量
        for (int i = 0; i < others.size(); i++) {
            xOthers[i] = solver.makeBoolVar("others_" + i);
        }

        // 3. 约束：每餐 1 肉 + 1 菜 + 1 碳水
        for (int m : MEALS) {
            // sum(xMeats[i][m]) = 1
            MPConstraint cMeat = solver.makeConstraint(1, 1, "One_meat_" + m);
            for (int i = 0; i < meats.size(); i++) {
                cMeat.setCoefficient(xMeats[i][m], 1.0);
            }

            // sum(xVegs[i][m]) = 1
            MPConstraint cVeg = solver.makeConstraint(1, 1, "One_veg_" + m);
            for (int i = 0; i < vegs.size(); i++) {
                cVeg.setCoefficient(xVegs[i][m], 1.0);
            }

            // sum(xCarbs[i][m]) = 1
            MPConstraint cCarb = solver.makeConstraint(1, 1, "One_carb_" + m);
            for (int i = 0; i < carbs.size(); i++) {
                cCarb.setCoefficient(xCarbs[i][m], 1.0);
            }
        }

        // 4. 午餐(m=1)选择一个others类型食物
        MPConstraint cOther = solver.makeConstraint(1, 1, "One_others");
        for (int i = 0; i < others.size(); i++) {
            cOther.setCoefficient(xOthers[i], 1.0);
        }

        // 5. 如果 noRepeat = true，则同一天同类食物不能重复
        if (noRepeat) {
            // meats
            for (int i = 0; i < meats.size(); i++) {
                MPConstraint c = solver.makeConstraint(0, 1, "No_repeat_meat_" + i);
                for (int m : MEALS) {
                    c.setCoefficient(xMeats[i][m], 1.0);
                }
            }
            // vegs
            for (int i = 0; i < vegs.size(); i++) {
                MPConstraint c = solver.makeConstraint(0, 1, "No_repeat_veg_" + i);
                for (int m : MEALS) {
                    c.setCoefficient(xVegs[i][m], 1.0);
                }
            }
            // carbs
            for (int i = 0; i < carbs.size(); i++) {
                MPConstraint c = solver.makeConstraint(0, 1, "No_repeat_carb_" + i);
                for (int m : MEALS) {
                    c.setCoefficient(xCarbs[i][m], 1.0);
                }
            }
        }

        // 6. 不再按照固定比例分配卡路里，而是约束总卡路里
        // 放宽约束：总热量在目标热量±5%的范围内即可
        double lowerBound = calorieTarget * 0.95; // 下界为目标热量的95%
        double upperBound = calorieTarget * 1.05; // 上界为目标热量的105%
        MPConstraint cTotalCal = solver.makeConstraint(lowerBound, upperBound, "Total_calorie");
        // 肉类贡献
        for (int i = 0; i < meats.size(); i++) {
            for (int m : MEALS) {
                cTotalCal.setCoefficient(xMeats[i][m], meats.get(i).getCaloricValue());
            }
        }
        // 蔬菜贡献
        for (int i = 0; i < vegs.size(); i++) {
            for (int m : MEALS) {
                cTotalCal.setCoefficient(xVegs[i][m], vegs.get(i).getCaloricValue());
            }
        }
        // 碳水贡献
        for (int i = 0; i < carbs.size(); i++) {
            for (int m : MEALS) {
                cTotalCal.setCoefficient(xCarbs[i][m], carbs.get(i).getCaloricValue());
            }
        }
        // others食物贡献(仅午餐)
        for (int i = 0; i < others.size(); i++) {
            cTotalCal.setCoefficient(xOthers[i], others.get(i).getCaloricValue());
        }

        // 7. 定义目标函数：最大化总营养密度(若 addRepeatPenalty，则减去一些重复惩罚)
        // 修改为：最小化与目标蛋白质:碳水:脂肪=3:2:8比例的偏差
        MPObjective objective = solver.objective();

        // 创建辅助变量表示总营养素的和
        MPVariable totalNutrients = solver.makeNumVar(0, Double.POSITIVE_INFINITY, "total_nutrients");
        MPConstraint cNutrientsSum = solver.makeConstraint(0, 0, "nutrients_sum");
        cNutrientsSum.setCoefficient(totalNutrients, -1);
        cNutrientsSum.setCoefficient(totalNutrients, 1);
        cNutrientsSum.setCoefficient(totalNutrients, 1);
        cNutrientsSum.setCoefficient(totalNutrients, 1);

        // 重新设计约束和目标函数
        // 创建表示每种营养素总量的辅助变量
        MPVariable totalProteinVar = solver.makeNumVar(0, Double.POSITIVE_INFINITY, "total_protein_var");
        MPVariable totalCarbsVar = solver.makeNumVar(0, Double.POSITIVE_INFINITY, "total_carbs_var");
        MPVariable totalFatVar = solver.makeNumVar(0, Double.POSITIVE_INFINITY, "total_fat_var");

        // 设置营养素总量约束
        MPConstraint cProteinTotal = solver.makeConstraint(0, 0, "protein_total");
        cProteinTotal.setCoefficient(totalProteinVar, 1);
        for (int i = 0; i < meats.size(); i++) {
            for (int m : MEALS) {
                cProteinTotal.setCoefficient(xMeats[i][m], -meats.get(i).getProtein());
            }
        }
        for (int i = 0; i < vegs.size(); i++) {
            for (int m : MEALS) {
                cProteinTotal.setCoefficient(xVegs[i][m], -vegs.get(i).getProtein());
            }
        }
        for (int i = 0; i < carbs.size(); i++) {
            for (int m : MEALS) {
                cProteinTotal.setCoefficient(xCarbs[i][m], -carbs.get(i).getProtein());
            }
        }
        for (int i = 0; i < others.size(); i++) {
            cProteinTotal.setCoefficient(xOthers[i], -others.get(i).getProtein());
        }

        MPConstraint cCarbsTotal = solver.makeConstraint(0, 0, "carbs_total");
        cCarbsTotal.setCoefficient(totalCarbsVar, 1);
        for (int i = 0; i < meats.size(); i++) {
            for (int m : MEALS) {
                cCarbsTotal.setCoefficient(xMeats[i][m], -meats.get(i).getCarbohydrates());
            }
        }
        for (int i = 0; i < vegs.size(); i++) {
            for (int m : MEALS) {
                cCarbsTotal.setCoefficient(xVegs[i][m], -vegs.get(i).getCarbohydrates());
            }
        }
        for (int i = 0; i < carbs.size(); i++) {
            for (int m : MEALS) {
                cCarbsTotal.setCoefficient(xCarbs[i][m], -carbs.get(i).getCarbohydrates());
            }
        }
        for (int i = 0; i < others.size(); i++) {
            cCarbsTotal.setCoefficient(xOthers[i], -others.get(i).getCarbohydrates());
        }

        MPConstraint cFatTotal = solver.makeConstraint(0, 0, "fat_total");
        cFatTotal.setCoefficient(totalFatVar, 1);
        for (int i = 0; i < meats.size(); i++) {
            for (int m : MEALS) {
                cFatTotal.setCoefficient(xMeats[i][m], -meats.get(i).getFat());
            }
        }
        for (int i = 0; i < vegs.size(); i++) {
            for (int m : MEALS) {
                cFatTotal.setCoefficient(xVegs[i][m], -vegs.get(i).getFat());
            }
        }
        for (int i = 0; i < carbs.size(); i++) {
            for (int m : MEALS) {
                cFatTotal.setCoefficient(xCarbs[i][m], -carbs.get(i).getFat());
            }
        }
        for (int i = 0; i < others.size(); i++) {
            cFatTotal.setCoefficient(xOthers[i], -others.get(i).getFat());
        }

        // 计算总营养素
        MPVariable totalNutrientsVar = solver.makeNumVar(0, Double.POSITIVE_INFINITY, "total_nutrients_var");
        MPConstraint cTotalNutrients = solver.makeConstraint(0, 0, "total_nutrients_calc");
        cTotalNutrients.setCoefficient(totalNutrientsVar, 1);
        cTotalNutrients.setCoefficient(totalProteinVar, -1);
        cTotalNutrients.setCoefficient(totalCarbsVar, -1);
        cTotalNutrients.setCoefficient(totalFatVar, -1);

        // 创建偏差变量
        MPVariable proteinRatioDev = solver.makeNumVar(0, Double.POSITIVE_INFINITY, "protein_ratio_dev");
        MPVariable carbsRatioDev = solver.makeNumVar(0, Double.POSITIVE_INFINITY, "carbs_ratio_dev");
        MPVariable fatRatioDev = solver.makeNumVar(0, Double.POSITIVE_INFINITY, "fat_ratio_dev");

        // 设置偏差约束
        // |蛋白质实际比例 - 目标比例| <= proteinRatioDev
        MPConstraint cProteinRatioDev1 = solver.makeConstraint(-Double.POSITIVE_INFINITY, 0, "protein_ratio_dev1");
        cProteinRatioDev1.setCoefficient(totalProteinVar, 1.0);
        cProteinRatioDev1.setCoefficient(totalNutrientsVar, -TARGET_PROTEIN_RATIO);
        cProteinRatioDev1.setCoefficient(proteinRatioDev, -1.0);

        MPConstraint cProteinRatioDev2 = solver.makeConstraint(0, Double.POSITIVE_INFINITY, "protein_ratio_dev2");
        cProteinRatioDev2.setCoefficient(totalProteinVar, 1.0);
        cProteinRatioDev2.setCoefficient(totalNutrientsVar, -TARGET_PROTEIN_RATIO);
        cProteinRatioDev2.setCoefficient(proteinRatioDev, 1.0);

        // |碳水实际比例 - 目标比例| <= carbsRatioDev
        MPConstraint cCarbsRatioDev1 = solver.makeConstraint(-Double.POSITIVE_INFINITY, 0, "carbs_ratio_dev1");
        cCarbsRatioDev1.setCoefficient(totalCarbsVar, 1.0);
        cCarbsRatioDev1.setCoefficient(totalNutrientsVar, -TARGET_CARBS_RATIO);
        cCarbsRatioDev1.setCoefficient(carbsRatioDev, -1.0);

        MPConstraint cCarbsRatioDev2 = solver.makeConstraint(0, Double.POSITIVE_INFINITY, "carbs_ratio_dev2");
        cCarbsRatioDev2.setCoefficient(totalCarbsVar, 1.0);
        cCarbsRatioDev2.setCoefficient(totalNutrientsVar, -TARGET_CARBS_RATIO);
        cCarbsRatioDev2.setCoefficient(carbsRatioDev, 1.0);

        // |脂肪实际比例 - 目标比例| <= fatRatioDev
        MPConstraint cFatRatioDev1 = solver.makeConstraint(-Double.POSITIVE_INFINITY, 0, "fat_ratio_dev1");
        cFatRatioDev1.setCoefficient(totalFatVar, 1.0);
        cFatRatioDev1.setCoefficient(totalNutrientsVar, -TARGET_FAT_RATIO);
        cFatRatioDev1.setCoefficient(fatRatioDev, -1.0);

        MPConstraint cFatRatioDev2 = solver.makeConstraint(0, Double.POSITIVE_INFINITY, "fat_ratio_dev2");
        cFatRatioDev2.setCoefficient(totalFatVar, 1.0);
        cFatRatioDev2.setCoefficient(totalNutrientsVar, -TARGET_FAT_RATIO);
        cFatRatioDev2.setCoefficient(fatRatioDev, 1.0);

        // 设置目标函数为最小化总偏差
        objective.setCoefficient(proteinRatioDev, 1.0);
        objective.setCoefficient(carbsRatioDev, 1.0);
        objective.setCoefficient(fatRatioDev, 1.0);

        // 如果需要考虑重复惩罚，添加适当的惩罚项
        if (addRepeatPenalty) {
            // 肉类
            for (int i = 0; i < meats.size(); i++) {
                double penalty = 0;
                for (int m = 1; m < MEALS.length; m++) {
                    for (int prevM = 0; prevM < m; prevM++) {
                        MPVariable indicator = solver.makeBoolVar("meat_repeat_" + i + "_" + m + "_" + prevM);
                        // indicator表示第i个肉类在餐m和餐prevM都被选中
                        // x[i][m] + x[i][prevM] - 1 <= indicator
                        MPConstraint c1 = solver.makeConstraint(-Double.POSITIVE_INFINITY, 1,
                                "meat_indicator_" + i + "_" + m + "_" + prevM);
                        c1.setCoefficient(xMeats[i][m], 1.0);
                        c1.setCoefficient(xMeats[i][prevM], 1.0);
                        c1.setCoefficient(indicator, -1.0);

                        objective.setCoefficient(indicator, ALPHA); // 添加惩罚
                    }
                }
            }

            // 蔬菜
            for (int i = 0; i < vegs.size(); i++) {
                double penalty = 0;
                for (int m = 1; m < MEALS.length; m++) {
                    for (int prevM = 0; prevM < m; prevM++) {
                        MPVariable indicator = solver.makeBoolVar("veg_repeat_" + i + "_" + m + "_" + prevM);
                        MPConstraint c1 = solver.makeConstraint(-Double.POSITIVE_INFINITY, 1,
                                "veg_indicator_" + i + "_" + m + "_" + prevM);
                        c1.setCoefficient(xVegs[i][m], 1.0);
                        c1.setCoefficient(xVegs[i][prevM], 1.0);
                        c1.setCoefficient(indicator, -1.0);

                        objective.setCoefficient(indicator, ALPHA);
                    }
                }
            }

            // 碳水
            for (int i = 0; i < carbs.size(); i++) {
                double penalty = 0;
                for (int m = 1; m < MEALS.length; m++) {
                    for (int prevM = 0; prevM < m; prevM++) {
                        MPVariable indicator = solver.makeBoolVar("carb_repeat_" + i + "_" + m + "_" + prevM);
                        MPConstraint c1 = solver.makeConstraint(-Double.POSITIVE_INFINITY, 1,
                                "carb_indicator_" + i + "_" + m + "_" + prevM);
                        c1.setCoefficient(xCarbs[i][m], 1.0);
                        c1.setCoefficient(xCarbs[i][prevM], 1.0);
                        c1.setCoefficient(indicator, -1.0);

                        objective.setCoefficient(indicator, ALPHA);
                    }
                }
            }
        }

        objective.setMinimization(); // 设置为最小化目标

        // 将构造好的 solver 和变量等打包返回
        return new ModelData(solver, xMeats, xVegs, xCarbs, xOthers);
    }

    /**
     * 枚举多个可行解，最多收集 maxSolutions 个。
     * 每次求解后，若得到可行解，则添加一个 "排除当前解" 的剪切约束，再继续求解，直到无解或达上限。
     *
     * @return 每个可行解对应的三餐食物列表(外层 list 长度 = 解的数量；内层 = 3；最内层 = 每餐3种食物)
     */
    private List<List<List<String>>> enumerateSolutions(
            ModelData modelData,
            List<Food> meats,
            List<Food> vegs,
            List<Food> carbs,
            List<Food> others,
            int maxSolutions) {
        MPSolver solver = modelData.solver;
        MPVariable[][] xMeats = modelData.xMeats;
        MPVariable[][] xVegs = modelData.xVegs;
        MPVariable[][] xCarbs = modelData.xCarbs;
        MPVariable[] xOthers = modelData.xOthers;

        List<List<List<String>>> solutions = new ArrayList<>();

        while (solutions.size() < maxSolutions) {
            // 1. 求解
            ResultStatus status = solver.solve();
            System.out.println("Solver status: " + status);
            if (status != ResultStatus.OPTIMAL) {
                // 无可行解或非最优 => 退出
                System.out.println("No optimal solution found, exiting solution enumeration");
                break;
            }

            // 2. 读取当前解
            List<List<String>> plan = getSolution(solver, xMeats, xVegs, xCarbs, xOthers, meats, vegs, carbs, others);
            if (plan == null) {
                // 如果无解, 退出
                break;
            }
            solutions.add(plan);

            // 3. 构造 "排除本解" 的剪切约束:
            // sum( (1 - x) if x=1 else x ) >= 1
            // 具体实现: 对于每个变量:
            // 若此解中 x=1 => 系数为 -1, 同时 constantOffset += 1
            // 若此解中 x=0 => 系数为 +1
            // => sum(coeff[i]*x[i]) + offset >= 1
            List<VarVal> chosenVars = new ArrayList<>();
            // meats
            for (int i = 0; i < meats.size(); i++) {
                for (int m : MEALS) {
                    int val = (int) Math.round(xMeats[i][m].solutionValue());
                    chosenVars.add(new VarVal(xMeats[i][m], val));
                }
            }
            // vegs
            for (int i = 0; i < vegs.size(); i++) {
                for (int m : MEALS) {
                    int val = (int) Math.round(xVegs[i][m].solutionValue());
                    chosenVars.add(new VarVal(xVegs[i][m], val));
                }
            }
            // carbs
            for (int i = 0; i < carbs.size(); i++) {
                for (int m : MEALS) {
                    int val = (int) Math.round(xCarbs[i][m].solutionValue());
                    chosenVars.add(new VarVal(xCarbs[i][m], val));
                }
            }

            // others (仅午餐使用)
            for (int i = 0; i < others.size(); i++) {
                int val = (int) Math.round(xOthers[i].solutionValue());
                chosenVars.add(new VarVal(xOthers[i], val));
            }

            // 在 solver 中新加一个约束: sum(coeff * var) >= 1 - offset
            double offset = 0.0;
            MPConstraint cutConstraint = solver.makeConstraint(1, Double.POSITIVE_INFINITY,
                    "CutSolution_" + (solutions.size()));
            for (VarVal vv : chosenVars) {
                if (vv.val == 1) {
                    // (1 - x), 系数是 -1, 并 offset += 1
                    cutConstraint.setCoefficient(vv.var, -1.0);
                    offset += 1.0;
                } else {
                    // x, 系数是 +1
                    cutConstraint.setCoefficient(vv.var, 1.0);
                }
            }
            // 因为 sum(coeff*var) + offset >= 1 等价于 sum(coeff*var) >= 1 - offset
            // 所以要调整下约束的下界
            double lb = 1.0 - offset;
            cutConstraint.setLb(lb);
        }

        System.out.println("Enumerated: " + solutions.size() + " solutions");
        return solutions;
    }

    /**
     * 从求解完成的 solver 中读取各餐选了哪些食物。
     *
     * @return plan: size=3 的列表，每餐对应 [meat, veg, carb] (字符串), 若无解返回 null
     */
    private List<List<String>> getSolution(
            MPSolver solver,
            MPVariable[][] xMeats,
            MPVariable[][] xVegs,
            MPVariable[][] xCarbs,
            MPVariable[] xOthers,
            List<Food> meats,
            List<Food> vegs,
            List<Food> carbs,
            List<Food> others) {
        // 如果解不可行
        if (solver.objective() == null) {
            return null;
        }

        // 三餐
        List<List<String>> plan = new ArrayList<>(3);
        for (int m = 0; m < 3; m++) {
            List<String> items = new ArrayList<>(3);

            // meats
            int chosenMeat = -1;
            for (int i = 0; i < meats.size(); i++) {
                if (Math.round(xMeats[i][m].solutionValue()) == 1) {
                    chosenMeat = i;
                    break;
                }
            }
            if (chosenMeat >= 0) {
                items.add(meats.get(chosenMeat).getFood());
            }

            // vegs
            int chosenVeg = -1;
            for (int i = 0; i < vegs.size(); i++) {
                if (Math.round(xVegs[i][m].solutionValue()) == 1) {
                    chosenVeg = i;
                    break;
                }
            }
            if (chosenVeg >= 0) {
                items.add(vegs.get(chosenVeg).getFood());
            }

            // carbs
            int chosenCarb = -1;
            for (int i = 0; i < carbs.size(); i++) {
                if (Math.round(xCarbs[i][m].solutionValue()) == 1) {
                    chosenCarb = i;
                    break;
                }
            }
            if (chosenCarb >= 0) {
                items.add(carbs.get(chosenCarb).getFood());
            }

            // 如果是午餐(m=1)，添加选中的others食物
            if (m == 1) {
                for (int i = 0; i < others.size(); i++) {
                    if (Math.round(xOthers[i].solutionValue()) == 1) {
                        items.add(others.get(i).getFood());
                    }
                }
            }

            plan.add(items);
        }

        return plan;
    }

    // === 一些简化写法的"布尔型"辅助方法 ===
    private boolean noRepeat(boolean v) {
        return v;
    }

    private boolean addRepeatPenalty(boolean v) {
        return v;
    }

    private int maxSolutions(int k) {
        return k;
    }

    /**
     * 内部数据结构，打包 solver 与变量
     */
    static class ModelData {
        MPSolver solver;
        MPVariable[][] xMeats;
        MPVariable[][] xVegs;
        MPVariable[][] xCarbs;
        MPVariable[] xOthers;

        public ModelData(MPSolver solver,
                MPVariable[][] xMeats,
                MPVariable[][] xVegs,
                MPVariable[][] xCarbs,
                MPVariable[] xOthers) {
            this.solver = solver;
            this.xMeats = xMeats;
            this.xVegs = xVegs;
            this.xCarbs = xCarbs;
            this.xOthers = xOthers;
        }
    }

    /**
     * 内部数据结构，用于保存"某个变量在当前解中取值"的信息
     */
    static class VarVal {
        MPVariable var;
        int val; // 0 or 1

        VarVal(MPVariable var, int val) {
            this.var = var;
            this.val = val;
        }
    }
}
./src/main/java/com/example/diettracker/service/FoodService.java
package com.example.diettracker.service;

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.stereotype.Service;

import com.example.diettracker.model.Food;
import com.example.diettracker.repository.FoodRepository;

import java.util.List;
import java.util.Optional;

@Service
public class FoodService {
    // When creating a FoodService instance, Spring automatically finds and injects
    // a matching Bean.
    // Here, Spring will find a FoodRepository Bean and inject it into the
    // foodRepository field.
    @Autowired
    private FoodRepository foodRepository;

    public List<Food> getAllFoods() {
        return foodRepository.findAll();
    }

    public Optional<Food> getFoodById(Long id) {
        return foodRepository.findById(id);
    }

    public List<Food> getFoodByFood(String food) {
        return foodRepository.findByFood(food);
    }

    public Food saveFood(Food food) {
        return foodRepository.save(food);
    }

    public Food updateFood(Food food) {
        return foodRepository.save(food);
    }

    public void deleteFood(Long id) {
        foodRepository.deleteById(id);
    }
}./src/main/java/com/example/diettracker/OrToolsInitializer.java
package com.example.diettracker;

import jakarta.annotation.PostConstruct;
import org.springframework.stereotype.Component;
import com.google.ortools.Loader;

@Component // This class is managed by Spring and will be initialized automatically
public class OrToolsInitializer {

    @PostConstruct
    public void init() {
        Loader.loadNativeLibraries();
        System.out.println("OR-Tools JNI library loaded successfully!");
    }
}
以下是要求:
计算基础代谢率（BMR）
BMR 表示人体在静息状态下维持基本生命活动所需的最低能量。常用的公式有两个：

Harris-Benedict 公式
男性：
BMR = 66.5 + (13.75 × 体重[kg]) + (5.003 × 身高[cm]) - (6.755 × 年龄)
女性：
BMR = 655.1 + (9.563 × 体重[kg]) + (1.850 × 身高[cm]) - (4.676 × 年龄)
Mifflin-St Jeor 公式（较为现代，许多研究认为更准确）
男性：
BMR = (10 × 体重[kg]) + (6.25 × 身高[cm]) - (5 × 年龄) + 5
女性：
BMR = (10 × 体重[kg]) + (6.25 × 身高[cm]) - (5 × 年龄) - 161
确定日常活动水平
根据你的生活和运动习惯，将 BMR 乘以一个活动系数，以得到每日总能量消耗（TDEE）：

久坐（几乎不运动）：BMR × 1.2
轻度活动（每周运动1-3次）：BMR × 1.375
中度活动（每周运动3-5次）：BMR × 1.55
高度活动（每周运动6-7次）：BMR × 1.725
非常活跃（体力劳动者或每天进行高强度训练）：BMR × 1.9
调整目标（减重、维持或增重）

如果目标是维持体重，则每日摄入热量建议与 TDEE 基本相同。
如果目标是减重，可以在 TDEE 的基础上减少约 500 卡路里/天（每周大约减少0.5公斤），但不要降低过多以免影响健康。
如果目标是增重，则需要适当增加热量摄入，比如在 TDEE 基础上增加 300-500 卡路里/天，同时结合适当的力量训练。
目前MealPlanService中的代码改成用计算出的tdee减去500卡路里 其他逻辑不要变化
